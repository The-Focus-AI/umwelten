---
globs: src/mcp/*.ts,src/mcp/**/*.ts
description: Model Context Protocol (MCP) integration patterns and usage
---

# MCP Integration Patterns

## Overview
The MCP (Model Context Protocol) integration provides both client and server frameworks for connecting to external tools and resources. This enables the umwelten tool to consume external MCP servers and expose its own tools to external applications.

## Architecture Components

### MCP Client (Stimulation)
Located in [src/mcp/client/](mdc:src/mcp/client/):
- **Connection Management**: Robust stdio, SSE, and WebSocket transport support
- **Tool Discovery**: Automatic discovery and integration of external MCP tools
- **Resource Access**: Reading and integration of external MCP resources
- **Type Safety**: Full TypeScript support with Zod validation
- **Integration**: Seamless integration with existing Interaction/Stimulus system

### MCP Server Framework
Located in [src/mcp/server/](mdc:src/mcp/server/):
- **Builder Pattern**: Easy server creation with fluent API
- **Tool Registration**: Dynamic tool registration and exposure
- **Resource Serving**: Configurable resource serving capabilities
- **Session Management**: Multi-client support with proper lifecycle
- **Transport Support**: stdio, SSE, and WebSocket transport options

## MCP Client Usage Pattern

### Basic Client Setup
```typescript
import { createMCPStimulusManager } from '../mcp/client/client';

// Connect to external MCP server for stimulation
const manager = createMCPStimulusManager({
  name: 'evaluation-client',
  version: '1.0.0',
  serverCommand: 'node external-mcp-server.js',
  autoConnect: true
});

// Use external tools in model interactions
const tools = manager.getAvailableTools();
const interaction = new Interaction(modelDetails, systemPrompt);
// Tools would be integrated into interaction
```

### Tool Discovery and Usage
```typescript
// Discover available tools
const tools = await manager.listTools();
console.log('Available tools:', tools.map(t => t.name));

// Execute a tool
const result = await manager.callTool('calculator', {
  operation: 'add',
  a: 5,
  b: 3
});
console.log('Result:', result.content);
```

### Resource Access
```typescript
// List available resources
const resources = await manager.listResources();
console.log('Available resources:', resources.map(r => r.uri));

// Read a resource
const content = await manager.readResource('file:///path/to/file.txt');
console.log('Resource content:', content);
```

## MCP Server Framework Usage

### Basic Server Creation
```typescript
import { createMCPServer } from '../mcp/server/server';

// Build custom MCP server to expose our tools
const server = createMCPServer()
  .withName('my-evaluation-server')
  .withVersion('1.0.0')
  .addTool('calculator', toolDef, handler)
  .addResource('results://data', resourceDef, handler)
  .build();

// Start server for external applications
await server.start(transport);
```

### Tool Registration
```typescript
// Define tool schema
const calculatorTool = {
  name: 'calculator',
  description: 'Perform mathematical calculations',
  inputSchema: {
    type: 'object',
    properties: {
      operation: { type: 'string', enum: ['add', 'subtract', 'multiply', 'divide'] },
      a: { type: 'number' },
      b: { type: 'number' }
    },
    required: ['operation', 'a', 'b']
  }
};

// Implement tool handler
const calculatorHandler = async (params: any) => {
  const { operation, a, b } = params;
  let result: number;
  
  switch (operation) {
    case 'add': result = a + b; break;
    case 'subtract': result = a - b; break;
    case 'multiply': result = a * b; break;
    case 'divide': result = a / b; break;
    default: throw new Error(`Unknown operation: ${operation}`);
  }
  
  return { content: [{ type: 'text', text: result.toString() }] };
};

// Register tool with server
server.addTool(calculatorTool, calculatorHandler);
```

### Resource Registration
```typescript
// Define resource schema
const resultsResource = {
  uri: 'results://data',
  name: 'evaluation-results',
  description: 'Access to evaluation results',
  mimeType: 'application/json'
};

// Implement resource handler
const resultsHandler = async () => {
  const results = await loadEvaluationResults();
  return {
    contents: [{
      uri: 'results://data',
      mimeType: 'application/json',
      text: JSON.stringify(results)
    }]
  };
};

// Register resource with server
server.addResource(resultsResource, resultsHandler);
```

## CLI Integration

### MCP Commands
The CLI includes comprehensive MCP support:

```bash
# Connect to MCP server
umwelten mcp connect --server "node external-server.js"

# Test specific tool
umwelten mcp test-tool calculator --params '{"operation":"add","a":5,"b":3}'

# Read resource
umwelten mcp read-resource file:///path/to/file.txt

# Create example server
umwelten mcp create-server --name my-server --output ./my-server.js
```

### Command Implementation
```typescript
// src/cli/mcp.ts
export function createMCPCommand(): Command {
  return new Command('mcp')
    .description('Model Context Protocol client and server management')
    .addCommand(createConnectCommand())
    .addCommand(createTestToolCommand())
    .addCommand(createReadResourceCommand())
    .addCommand(createCreateServerCommand());
}
```

## Transport Support

### Available Transports
1. **stdio**: Standard input/output for local servers
2. **SSE**: Server-Sent Events for web-based servers
3. **WebSocket**: Real-time bidirectional communication

### Transport Configuration
```typescript
// stdio transport
const stdioTransport = {
  type: 'stdio' as const,
  command: 'node my-server.js'
};

// SSE transport
const sseTransport = {
  type: 'sse' as const,
  url: 'http://localhost:3000/mcp'
};

// WebSocket transport
const wsTransport = {
  type: 'websocket' as const,
  url: 'ws://localhost:8080/mcp'
};
```

## Error Handling

### Connection Errors
```typescript
try {
  await manager.connect();
} catch (error) {
  if (error instanceof ConnectionError) {
    console.error('Failed to connect to MCP server:', error.message);
  } else if (error instanceof AuthenticationError) {
    console.error('Authentication failed:', error.message);
  }
}
```

### Tool Execution Errors
```typescript
try {
  const result = await manager.callTool('calculator', params);
  console.log('Tool result:', result);
} catch (error) {
  if (error instanceof ToolNotFoundError) {
    console.error('Tool not found:', error.toolName);
  } else if (error instanceof ToolExecutionError) {
    console.error('Tool execution failed:', error.message);
  }
}
```

## Type Safety

### Zod Schemas
```typescript
import { z } from 'zod';

// Tool input schema
const CalculatorInputSchema = z.object({
  operation: z.enum(['add', 'subtract', 'multiply', 'divide']),
  a: z.number(),
  b: z.number()
});

// Tool output schema
const CalculatorOutputSchema = z.object({
  content: z.array(z.object({
    type: z.literal('text'),
    text: z.string()
  }))
});
```

### Type Definitions
```typescript
// MCP protocol types
interface MCPTool {
  name: string;
  description: string;
  inputSchema: z.ZodSchema;
}

interface MCPResource {
  uri: string;
  name: string;
  description: string;
  mimeType: string;
}

interface MCPTransport {
  type: 'stdio' | 'sse' | 'websocket';
  command?: string;
  url?: string;
}
```

## Integration with Existing Systems

### Stimulus Integration
```typescript
// Integrate MCP tools with stimulus system
class MCPStimulus extends Stimulus {
  constructor(
    private mcpManager: MCPStimulusManager,
    content: string,
    tools?: string[]
  ) {
    super(content);
    this.availableTools = tools || [];
  }

  async getTools(): Promise<Tool[]> {
    const mcpTools = await this.mcpManager.listTools();
    return mcpTools.filter(tool => 
      this.availableTools.includes(tool.name)
    );
  }
}
```

### Interaction Integration
```typescript
// Use MCP tools in interactions
const interaction = new Interaction(modelDetails, systemPrompt);
const mcpStimulus = new MCPStimulus(mcpManager, prompt, ['calculator']);

// Add MCP tools to interaction
interaction.addStimulus(mcpStimulus);
```

## Best Practices

### Server Development
1. **Use the builder pattern** for easy server creation
2. **Implement proper error handling** for all tools and resources
3. **Validate inputs** using Zod schemas
4. **Document tools and resources** clearly
5. **Handle multiple clients** gracefully

### Client Development
1. **Connect early** to establish communication
2. **Cache tool definitions** for better performance
3. **Handle connection failures** gracefully
4. **Validate tool inputs** before sending
5. **Implement retry logic** for transient failures

### Security Considerations
1. **Validate all inputs** from external tools
2. **Sanitize resource content** before processing
3. **Implement authentication** for sensitive operations
4. **Log tool executions** for audit purposes
5. **Handle resource limits** appropriately

## Testing MCP Integration

### Client Testing
```typescript
describe('MCP Client', () => {
  it('should connect to server successfully', async () => {
    const manager = createMCPStimulusManager({
      name: 'test-client',
      version: '1.0.0',
      serverCommand: 'node test-server.js'
    });

    await expect(manager.connect()).resolves.not.toThrow();
  });

  it('should execute tools correctly', async () => {
    const result = await manager.callTool('calculator', {
      operation: 'add',
      a: 2,
      b: 3
    });

    expect(result.content[0].text).toBe('5');
  });
});
```

### Server Testing
```typescript
describe('MCP Server', () => {
  it('should register tools correctly', () => {
    const server = createMCPServer()
      .withName('test-server')
      .addTool(calculatorTool, calculatorHandler);

    expect(server.getTools()).toHaveLength(1);
    expect(server.getTools()[0].name).toBe('calculator');
  });
});
``` 
description:
globs:
alwaysApply: false
---
