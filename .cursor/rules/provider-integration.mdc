---
globs: src/providers/*.ts,src/providers/*.test.ts
description: Provider integration patterns and requirements for AI model providers
---

# Provider Integration Guide

## Critical Requirements
1. **ALWAYS use Vercel AI SDK wrappers** for ALL providers
   - OpenRouter: @openrouter/ai-sdk-provider
   - Google: @ai-sdk/google
   - Ollama: ollama-ai-provider
   - LM Studio: Custom REST API wrapper
2. **NEVER use provider-specific SDKs directly** (e.g., @google/generative-ai)
3. All providers must implement the `LanguageModelV1` interface from 'ai' package
4. This ensures consistent interfaces and behavior across all providers

## Provider Interface
All providers must implement this interface:
```typescript
export interface Provider {
  getModelUrls(): Promise<Record<string, string>>;
  getAvailableModels(): Promise<ModelDetails[]>;
  calculateCosts(model: string, promptTokens: number, completionTokens: number): ModelCosts;
}
```

## Implementation Steps

### 1. Create Provider File
- Add provider-specific configuration
- Implement core interfaces
- Add type definitions
- Handle authentication

### 2. Required Components
- **Model URL generation logic**: Map model IDs to provider URLs
- **Available models fetching**: Retrieve and transform model lists
- **Cost calculation implementation**: Token-based pricing
- **Type definitions and validation**: Zod schemas for data validation
- **Error handling and retries**: Exponential backoff for transient errors
- **Rate limit management**: Respect provider-specific limits

### 3. Integration Steps
a. **Create Provider File**
   - Add provider-specific configuration
   - Implement core interfaces
   - Add type definitions
   - Handle authentication

b. **Update Core Files**
   - Add to provider index in [src/providers/index.ts](mdc:src/providers/index.ts)
   - Update model interfaces if needed
   - Add new capabilities or features
   - Update type definitions

c. **Testing**
   - Create provider test file (e.g., [src/providers/google.test.ts](mdc:src/providers/google.test.ts))
   - Add unit tests for core functionality
   - Add integration tests
   - Test error scenarios
   - Verify cost calculations

d. **Documentation**
   - Update README with new provider
   - Document authentication requirements
   - Add usage examples
   - Update environment variables

## Provider-Specific Considerations

### Authentication
- API key management via environment variables
- Configuration validation
- Security best practices
- Error handling for invalid credentials

### Rate Limiting
- Provider-specific limits
- Retry strategies with exponential backoff
- Concurrent request handling
- Rate limit detection and recovery

### Cost Management
- Token counting methods
- Price calculation per provider
- Usage tracking
- Budget controls

### Error Handling
- Provider-specific errors
- Retry strategies for transient errors
- User feedback
- Logging requirements

### Model Capabilities
- Feature support (text, vision, etc.)
- Token limits
- Special parameters
- Performance characteristics

## Example Implementation Pattern
```typescript
// 1. Import core interfaces only
import type { ModelDetails } from '../cognition/models';

// 2. Static data with const assertion
const PRICING = {
  'model-a': { promptTokens: 0.001, completionTokens: 0.002 },
  default: { promptTokens: 0.0005, completionTokens: 0.001 }
} as const;

// 3. Direct transformation to core interface
async function getModels(): Promise<ModelDetails[]> {
  const data = await fetchFromAPI();
  
  return data.models.map(model => ({
    id: model.id,
    name: model.name,
    provider: 'provider' as const,
    costs: PRICING[model.id] || PRICING.default,
    // ... other direct mappings
  }));
}
```

## Validation Checklist
- [ ] Core interface implementation complete
- [ ] Error handling implemented
- [ ] Rate limiting configured
- [ ] Tests written and passing
- [ ] Documentation updated
- [ ] Examples added
- [ ] Cost calculation verified
- [ ] Type definitions complete

## Common Patterns
- Authentication handling
- Rate limit implementation
- Error classification
- Cost calculation
- Model capability mapping
- URL generation

## Testing Requirements
- Unit tests for core functionality
- Integration tests with actual API
- Error scenario coverage
- Rate limit testing
- Cost calculation verification
- Type safety validation

## Documentation Requirements
- Setup instructions
- Authentication guide
- Environment variables
- Usage examples
- Rate limit details
- Cost calculation explanation
- Troubleshooting guide
