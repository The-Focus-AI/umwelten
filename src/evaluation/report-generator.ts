/**
 * Report Generator
 * Utilities for generating comprehensive reports from evaluation results
 */

import fs from 'fs';
import path from 'path';
import { extractTypeScriptCode, analyzeTypeScriptCode } from './typescript-code-extractor.js';
import { DockerRunResult } from './docker-runner.js';

export interface ModelResponse {
  content: string;
  metadata: {
    model: string;
    provider: string;
    tokenUsage?: {
      promptTokens: number;
      completionTokens: number;
      total: number;
    };
    startTime?: Date;
    endTime?: Date;
  };
}

export interface EvaluationReport {
  totalModels: number;
  successfulBuilds: number;
  successfulTests: number;
  goodCodeQuality: number;
  modelsWithCode: number;
  modelsWithSyntaxErrors: number;
  modelsWithES6Imports: number;
  averageResponseLength: number;
  averageTokensUsed: number;
  results: ModelResult[];
}

export interface ModelResult {
  modelName: string;
  buildStatus: 'success' | 'failed' | 'unknown';
  testStatus: 'success' | 'failed' | 'unknown';
  codeQuality: 'good' | 'syntax_errors' | 'poor' | 'unknown';
  codeLength: number;
  keywords: number;
  hasConsoleLog: boolean;
  hasTarget1042: boolean;
  notes: string;
}

/**
 * Generates comprehensive evaluation reports
 */
export class ReportGenerator {
  /**
   * Generates a Docker testing results report
   */
  static generateDockerResultsReport(
    responsesDir: string, 
    dockerDir: string, 
    dockerResults: DockerRunResult[]
  ): void {
    const reportPath = path.join(dockerDir, 'docker-testing-results.md');
    
    // Read all response files
    const responseFiles = fs.readdirSync(responsesDir).filter(file => file.endsWith('.json'));
    
    let report = `# Docker Testing Results - Show Name Generators

## Overview
This report summarizes the results of testing TypeScript code generated by different Ollama models for creating show names.

**Test Date**: ${new Date().toISOString()}
**Total Models Tested**: ${responseFiles.length}

## Test Results Summary

| Model | Build Status | Test Status | Code Quality | Notes |
|-------|-------------|-------------|--------------|-------|
`;
    
    const results: ModelResult[] = [];
    
    for (const file of responseFiles) {
      const modelName = file.replace('-ollama.json', '');
      const responsePath = path.join(responsesDir, file);
      
      try {
        const responseData: ModelResponse = JSON.parse(fs.readFileSync(responsePath, 'utf8'));
        const typescriptCode = extractTypeScriptCode(responseData.content);
        
        let buildStatus: 'success' | 'failed' | 'unknown' = 'unknown';
        let testStatus: 'success' | 'failed' | 'unknown' = 'unknown';
        let codeQuality: 'good' | 'syntax_errors' | 'poor' | 'unknown' = 'unknown';
        let notes = '';
        
        if (typescriptCode) {
          const analysis = analyzeTypeScriptCode(typescriptCode);
          
          if (analysis.hasSyntaxErrors) {
            codeQuality = 'syntax_errors';
            notes = 'Had syntax errors in loop conditions, manually fixed';
          } else if (analysis.imports > 0) {
            codeQuality = 'good';
            notes = 'Uses ES6 import statements';
          } else {
            codeQuality = 'good';
          }
          
          if (analysis.hasConsoleLog && analysis.hasTarget1042) {
            testStatus = 'success';
          } else {
            testStatus = 'failed';
            notes += '; Missing console.log or 1042 target';
          }
          
          buildStatus = 'success';
        } else {
          buildStatus = 'failed';
          testStatus = 'failed';
          codeQuality = 'poor';
          notes = 'No TypeScript code found';
        }
        
        results.push({
          modelName,
          buildStatus,
          testStatus,
          codeQuality,
          codeLength: typescriptCode?.length || 0,
          keywords: typescriptCode ? analyzeTypeScriptCode(typescriptCode).keywords : 0,
          hasConsoleLog: typescriptCode?.includes('console.log') || false,
          hasTarget1042: typescriptCode?.includes('1042') || false,
          notes
        });
        
        // Find corresponding Docker result
        const dockerResult = dockerResults.find(r => r.modelName === modelName);
        const executionStatusEmoji = dockerResult?.success ? '✅' : '❌';
        const codeQualityEmoji = codeQuality === 'good' ? '✅' : codeQuality === 'syntax_errors' ? '⚠️' : '❌';
        
        report += `| ${modelName} | ${executionStatusEmoji} ${dockerResult?.success ? 'Success' : 'Failed'} | ${codeQualityEmoji} ${codeQuality === 'good' ? 'Good' : codeQuality === 'syntax_errors' ? 'Syntax Errors (Fixed)' : 'Poor'} | ${notes} |\n`;
        
      } catch (error) {
        report += `| ${modelName} | ❌ Error | ❌ Error | ❌ Error | Error: ${error} |\n`;
      }
    }
    
    // Add summary statistics
    const successfulExecutions = dockerResults.filter(r => r.success).length;
    const goodCodeQuality = results.filter(r => r.codeQuality === 'good').length;
    
    report += `
## Statistics
- **Successful Executions**: ${successfulExecutions}/${responseFiles.length} (${Math.round(successfulExecutions/responseFiles.length*100)}%)
- **Good Code Quality**: ${goodCodeQuality}/${responseFiles.length} (${Math.round(goodCodeQuality/responseFiles.length*100)}%)

## Key Findings

### ✅ Working Models
${dockerResults.filter(r => r.success).map(r => `- **${r.modelName}**: Generated valid TypeScript code that compiles and runs`).join('\n')}

### ❌ Failed Models  
${dockerResults.filter(r => !r.success).map(r => `- **${r.modelName}**: ${r.error || 'Failed to generate working code'}`).join('\n')}

## Code Quality Analysis

### Common Patterns
- **ES6 Imports**: ${results.filter(r => r.notes.includes('ES6 imports')).length} models used modern import syntax
- **Syntax Errors**: ${results.filter(r => r.notes.includes('Syntax Errors')).length} models had syntax issues that were fixable
- **Console Output**: ${results.filter(r => r.hasConsoleLog).length} models properly implemented console.log output

### Code Generation Approaches
1. **Template-based**: Models that used arrays of words and combined them systematically
2. **Class-based**: Models that created classes with methods for generating names
3. **Function-based**: Models that used simple functions to generate combinations

## Docker Environment
Each model has its own Docker environment with:
- TypeScript compilation setup
- Node.js runtime
- Automated testing script
- Complete isolation from other models

## Recommendations
1. **Pre-testing**: Run syntax validation before Docker builds
2. **Error handling**: Add better error detection for common TypeScript issues
3. **Code review**: Manually review generated code for edge cases
4. **Standardization**: Consider standardizing the output format across models

---
*Report generated automatically from Docker testing results*
`;

    fs.writeFileSync(reportPath, report);
  }
  
  /**
   * Generates a comprehensive evaluation report
   */
  static generateEvaluationReport(responses: ModelResponse[]): EvaluationReport {
    const results: ModelResult[] = [];
    
    for (const response of responses) {
      const typescriptCode = extractTypeScriptCode(response.content);
      const analysis = typescriptCode ? analyzeTypeScriptCode(typescriptCode) : null;
      
      let buildStatus: 'success' | 'failed' | 'unknown' = 'unknown';
      let testStatus: 'success' | 'failed' | 'unknown' = 'unknown';
      let codeQuality: 'good' | 'syntax_errors' | 'poor' | 'unknown' = 'unknown';
      let notes = '';
      
      if (typescriptCode) {
        if (analysis?.hasSyntaxErrors) {
          codeQuality = 'syntax_errors';
          notes = 'Has syntax errors that need fixing';
        } else if (analysis?.imports && analysis.imports > 0) {
          codeQuality = 'good';
          notes = 'Uses ES6 imports';
        } else {
          codeQuality = 'good';
        }
        
        if (analysis?.hasConsoleLog && analysis?.hasTarget1042) {
          testStatus = 'success';
        } else {
          testStatus = 'failed';
          notes += '; Missing console.log or 1042 target';
        }
        
        buildStatus = 'success';
      } else {
        buildStatus = 'failed';
        testStatus = 'failed';
        codeQuality = 'poor';
        notes = 'No TypeScript code found';
      }
      
      results.push({
        modelName: response.metadata.model,
        buildStatus,
        testStatus,
        codeQuality,
        codeLength: typescriptCode?.length || 0,
        keywords: analysis?.keywords || 0,
        hasConsoleLog: analysis?.hasConsoleLog || false,
        hasTarget1042: analysis?.hasTarget1042 || false,
        notes
      });
    }
    
    const successfulBuilds = results.filter(r => r.buildStatus === 'success').length;
    const successfulTests = results.filter(r => r.testStatus === 'success').length;
    const goodCodeQuality = results.filter(r => r.codeQuality === 'good').length;
    const modelsWithCode = results.filter(r => r.codeLength > 0).length;
    const modelsWithSyntaxErrors = results.filter(r => r.codeQuality === 'syntax_errors').length;
    const modelsWithES6Imports = results.filter(r => r.notes.includes('ES6 imports')).length;
    
    const averageResponseLength = Math.round(
      responses.reduce((sum, r) => sum + r.content.length, 0) / responses.length
    );
    
    const averageTokensUsed = Math.round(
      responses.reduce((sum, r) => sum + (r.metadata.tokenUsage?.completionTokens || 0), 0) / responses.length
    );
    
    return {
      totalModels: responses.length,
      successfulBuilds,
      successfulTests,
      goodCodeQuality,
      modelsWithCode,
      modelsWithSyntaxErrors,
      modelsWithES6Imports,
      averageResponseLength,
      averageTokensUsed,
      results
    };
  }
}
