/**
 * Docker Environment Generator
 * Utilities for creating Docker environments for TypeScript code testing
 */

import fs from 'fs';
import path from 'path';
import { extractTypeScriptCode, fixCommonTypeScriptErrors } from './typescript-code-extractor.js';

export interface DockerEnvironmentConfig {
  modelName: string;
  typescriptCode: string;
  outputDir: string;
}

export interface DockerTestResult {
  modelName: string;
  buildSuccess: boolean;
  testSuccess: boolean;
  error?: string;
  output?: string;
}

/**
 * Creates a complete Docker environment for testing TypeScript code
 */
export class DockerEnvironmentGenerator {
  /**
   * Generates a complete Docker environment for a model
   */
  static generateEnvironment(config: DockerEnvironmentConfig): void {
    const { modelName, typescriptCode, outputDir } = config;
    
    // Create model-specific directory
    const modelDir = path.join(outputDir, modelName.replace(/[^a-zA-Z0-9]/g, '-'));
    if (!fs.existsSync(modelDir)) {
      fs.mkdirSync(modelDir, { recursive: true });
    }
    
    // Fix common TypeScript errors
    const fixedCode = fixCommonTypeScriptErrors(typescriptCode);
    
    // Write TypeScript file
    const tsFilePath = path.join(modelDir, 'generate-shows.ts');
    fs.writeFileSync(tsFilePath, fixedCode);
    
    // Create package.json
    const packageJson = {
      name: `show-generator-${modelName.replace(/[^a-zA-Z0-9]/g, '-')}`,
      version: '1.0.0',
      description: `Show name generator from ${modelName}`,
      main: 'generate-shows.ts',
      scripts: {
        start: 'ts-node generate-shows.ts',
        build: 'tsc generate-shows.ts',
        test: 'node generate-shows.js'
      },
      dependencies: {
        'typescript': '^5.0.0',
        'ts-node': '^10.9.0',
        '@types/node': '^20.0.0'
      },
      devDependencies: {}
    };
    
    fs.writeFileSync(path.join(modelDir, 'package.json'), JSON.stringify(packageJson, null, 2));
    
    // Create tsconfig.json
    const tsConfig = {
      compilerOptions: {
        target: 'ES2020',
        module: 'commonjs',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        outDir: './dist'
      },
      include: ['*.ts'],
      exclude: ['node_modules']
    };
    
    fs.writeFileSync(path.join(modelDir, 'tsconfig.json'), JSON.stringify(tsConfig, null, 2));
    
    // Create Dockerfile
    const dockerfile = this.generateDockerfile(modelName);
    fs.writeFileSync(path.join(modelDir, 'Dockerfile'), dockerfile);
    
    // Create .dockerignore
    const dockerignore = `node_modules
npm-debug.log
dist
.git
.gitignore
README.md
`;
    
    fs.writeFileSync(path.join(modelDir, '.dockerignore'), dockerignore);
    
    // Create README
    const readme = this.generateReadme(modelName, typescriptCode.length);
    fs.writeFileSync(path.join(modelDir, 'README.md'), readme);
  }
  
  /**
   * Generates a Dockerfile for the model
   */
  private static generateDockerfile(modelName: string): string {
    return `# Dockerfile for ${modelName} show generator
FROM node:18-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./
COPY tsconfig.json ./

# Install dependencies
RUN npm install

# Copy TypeScript source
COPY generate-shows.ts ./

# Build TypeScript
RUN npm run build

# Create a simple test script
RUN echo 'console.log("Testing show generator...");' > test.js
RUN echo 'const fs = require("fs");' >> test.js
RUN echo 'try {' >> test.js
RUN echo '  require("./generate-shows.js");' >> test.js
RUN echo '  console.log("‚úÖ Show generator executed successfully!");' >> test.js
RUN echo '} catch (error) {' >> test.js
RUN echo '  console.error("‚ùå Error running show generator:", error.message);' >> test.js
RUN echo '  process.exit(1);' >> test.js
RUN echo '}' >> test.js

# Run the test
CMD ["node", "test.js"]
`;
  }
  
  /**
   * Generates a README for the model
   */
  private static generateReadme(modelName: string, codeLength: number): string {
    return `# Show Generator - ${modelName}

This directory contains the TypeScript code generated by ${modelName} for creating show names.

## Files
- \`generate-shows.ts\` - The extracted TypeScript code (${codeLength} characters)
- \`Dockerfile\` - Docker configuration to run the code
- \`package.json\` - Node.js dependencies
- \`tsconfig.json\` - TypeScript configuration

## Running with Docker

\`\`\`bash
# Build the Docker image
docker build -t show-generator-${modelName.replace(/[^a-zA-Z0-9]/g, '-')} .

# Run the container
docker run show-generator-${modelName.replace(/[^a-zA-Z0-9]/g, '-')}
\`\`\`

## Running locally

\`\`\`bash
# Install dependencies
npm install

# Run with ts-node
npm start

# Or build and run
npm run build
npm test
\`\`\`

## Original Response
Generated from: ${modelName}
Code length: ${codeLength} characters
`;
  }
  
  /**
   * Creates a master test script for all models
   */
  static generateMasterTestScript(outputDir: string): void {
    const masterScript = `#!/bin/bash
# Master script to build and test all show generators

echo "üê≥ Building and testing all show generators..."
echo "=================================================="

cd "$(dirname "$0")"

for dir in */; do
  if [ -d "$dir" ] && [ -f "$dir/Dockerfile" ]; then
    model_name=$(basename "$dir")
    echo "\\nüî® Building $model_name..."
    
    cd "$dir"
    
    # Build Docker image
    docker build -t "show-generator-$model_name" . 2>/dev/null
    
    if [ $? -eq 0 ]; then
      echo "‚úÖ Build successful for $model_name"
      
      echo "üß™ Testing $model_name..."
      # Run container with timeout
      timeout 30s docker run --rm "show-generator-$model_name" 2>/dev/null
      
      if [ $? -eq 0 ]; then
        echo "‚úÖ Test passed for $model_name"
      else
        echo "‚ùå Test failed for $model_name"
      fi
    else
      echo "‚ùå Build failed for $model_name"
    fi
    
    cd ..
  fi
done

echo "\\nüìä Summary:"
echo "Check the output above for build and test results for each model."
`;
    
    fs.writeFileSync(path.join(outputDir, 'test-all.sh'), masterScript);
    fs.chmodSync(path.join(outputDir, 'test-all.sh'), '755');
  }
  
  /**
   * Tests a single Docker environment
   */
  static async testDockerEnvironment(modelDir: string): Promise<DockerTestResult> {
    const modelName = path.basename(modelDir);
    
    try {
      // Build Docker image
      const buildResult = await this.runCommand(`cd "${modelDir}" && docker build -t "test-${modelName}" .`);
      
      if (buildResult.exitCode !== 0) {
        return {
          modelName,
          buildSuccess: false,
          testSuccess: false,
          error: `Build failed: ${buildResult.stderr}`
        };
      }
      
      // Run Docker container
      const testResult = await this.runCommand(`docker run --rm "test-${modelName}"`);
      
      return {
        modelName,
        buildSuccess: true,
        testSuccess: testResult.exitCode === 0,
        output: testResult.stdout,
        error: testResult.exitCode !== 0 ? testResult.stderr : undefined
      };
      
    } catch (error) {
      return {
        modelName,
        buildSuccess: false,
        testSuccess: false,
        error: `Error: ${error.message}`
      };
    }
  }
  
  /**
   * Runs a shell command
   */
  private static async runCommand(command: string): Promise<{ exitCode: number; stdout: string; stderr: string }> {
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    
    const execAsync = promisify(exec);
    
    try {
      const { stdout, stderr } = await execAsync(command);
      return { exitCode: 0, stdout, stderr };
    } catch (error: any) {
      return { 
        exitCode: error.code || 1, 
        stdout: error.stdout || '', 
        stderr: error.stderr || error.message 
      };
    }
  }
}
